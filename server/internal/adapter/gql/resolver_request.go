package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/request"
	"github.com/reearth/reearthx/account/accountdomain"
	"github.com/reearth/reearthx/util"
	"github.com/samber/lo"
)

// CreateRequest is the resolver for the createRequest field.
func (r *mutationResolver) CreateRequest(ctx context.Context, input gqlmodel.CreateRequestInput) (*gqlmodel.RequestPayload, error) {
	pid, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}
	reviewers, err := util.TryMap(input.ReviewersID, gqlmodel.ToID[accountdomain.User])
	if err != nil {
		return nil, err
	}
	items, err := util.TryMap(input.Items, func(i *gqlmodel.RequestItemInput) (*request.Item, error) {
		iid, err := gqlmodel.ToID[id.Item](i.ItemID)
		if err != nil {
			return nil, err
		}

		return request.NewItem(iid, i.Version)
	})
	if err != nil {
		return nil, err
	}
	uc := usecases(ctx).Request
	params := interfaces.CreateRequestParam{
		ProjectID:   pid,
		Title:       input.Title,
		Description: input.Description,
		State:       lo.ToPtr(request.StateFrom(input.State.String())),
		Reviewers:   reviewers,
		Items:       items,
	}

	res, err := uc.Create(ctx, params, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.RequestPayload{
		Request: gqlmodel.ToRequest(res),
	}, nil
}

// UpdateRequest is the resolver for the updateRequest field.
func (r *mutationResolver) UpdateRequest(ctx context.Context, input gqlmodel.UpdateRequestInput) (*gqlmodel.RequestPayload, error) {
	rid, err := gqlmodel.ToID[id.Request](input.RequestID)
	if err != nil {
		return nil, err
	}
	reviewers, err := gqlmodel.ToIDs[accountdomain.User](input.ReviewersID)
	if err != nil {
		return nil, err
	}
	items, err := util.TryMap(input.Items, func(i *gqlmodel.RequestItemInput) (*request.Item, error) {
		iid, err := gqlmodel.ToID[id.Item](i.ItemID)
		if err != nil {
			return nil, err
		}

		return request.NewItem(iid, i.Version)
	})
	if err != nil {
		return nil, err
	}
	uc := usecases(ctx).Request
	params := interfaces.UpdateRequestParam{
		RequestID:   rid,
		Title:       input.Title,
		Description: input.Description,
		State:       lo.ToPtr(request.StateFrom(input.State.String())),
		Reviewers:   reviewers,
		Items:       items,
	}

	res, err := uc.Update(ctx, params, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.RequestPayload{
		Request: gqlmodel.ToRequest(res),
	}, nil
}

// ApproveRequest is the resolver for the approveRequest field.
func (r *mutationResolver) ApproveRequest(ctx context.Context, input gqlmodel.ApproveRequestInput) (*gqlmodel.RequestPayload, error) {
	rid, err := gqlmodel.ToID[id.Request](input.RequestID)
	if err != nil {
		return nil, err
	}
	res, err := usecases(ctx).Request.Approve(ctx, rid, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.RequestPayload{
		Request: gqlmodel.ToRequest(res),
	}, nil
}

// DeleteRequest is the resolver for the deleteRequest field.
func (r *mutationResolver) DeleteRequest(ctx context.Context, input gqlmodel.DeleteRequestInput) (*gqlmodel.DeleteRequestPayload, error) {
	rids, err := gqlmodel.ToIDs[id.Request](input.RequestsID)
	if err != nil {
		return nil, err
	}
	pid, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	err = usecases(ctx).Request.CloseAll(ctx, pid, rids, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteRequestPayload{
		Requests: input.RequestsID,
	}, nil
}

// Requests is the resolver for the requests field.
func (r *queryResolver) Requests(ctx context.Context, projectID gqlmodel.ID, key *string, state []gqlmodel.RequestState, createdBy *gqlmodel.ID, reviewer *gqlmodel.ID, pagination *gqlmodel.Pagination, sort *gqlmodel.Sort) (*gqlmodel.RequestConnection, error) {
	return loaders(ctx).Request.FindByProject(ctx, projectID, key, state, createdBy, reviewer, pagination, sort)
}

// Thread is the resolver for the thread field.
func (r *requestResolver) Thread(ctx context.Context, obj *gqlmodel.Request) (*gqlmodel.Thread, error) {
	if obj.ThreadID == nil {
		return nil, nil
	}
	return dataloaders(ctx).Thread.Load(*obj.ThreadID)
}

// CreatedBy is the resolver for the createdBy field.
func (r *requestResolver) CreatedBy(ctx context.Context, obj *gqlmodel.Request) (*gqlmodel.User, error) {
	return dataloaders(ctx).User.Load(obj.CreatedByID)
}

// Workspace is the resolver for the workspace field.
func (r *requestResolver) Workspace(ctx context.Context, obj *gqlmodel.Request) (*gqlmodel.Workspace, error) {
	return dataloaders(ctx).Workspace.Load(obj.WorkspaceID)
}

// Project is the resolver for the project field.
func (r *requestResolver) Project(ctx context.Context, obj *gqlmodel.Request) (*gqlmodel.Project, error) {
	return dataloaders(ctx).Project.Load(obj.ProjectID)
}

// Reviewers is the resolver for the reviewers field.
func (r *requestResolver) Reviewers(ctx context.Context, obj *gqlmodel.Request) ([]*gqlmodel.User, error) {
	res, errors := dataloaders(ctx).User.LoadAll(obj.ReviewersID)
	if len(res) > 0 && errors[0] != nil {
		return nil, errors[0]
	}
	return res, nil
}

// Item is the resolver for the item field.
func (r *requestItemResolver) Item(ctx context.Context, obj *gqlmodel.RequestItem) (*gqlmodel.VersionedItem, error) {
	return loaders(ctx).Item.FindVersionedItem(ctx, obj.ItemID, obj.Version)
}

// Request returns RequestResolver implementation.
func (r *Resolver) Request() RequestResolver { return &requestResolver{r} }

// RequestItem returns RequestItemResolver implementation.
func (r *Resolver) RequestItem() RequestItemResolver { return &requestItemResolver{r} }

type requestResolver struct{ *Resolver }
type requestItemResolver struct{ *Resolver }
