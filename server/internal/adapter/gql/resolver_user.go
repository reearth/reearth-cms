package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter"
	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearthx/account/accountdomain"
	"github.com/reearth/reearthx/account/accountdomain/user"
	"github.com/reearth/reearthx/account/accountusecase/accountinterfaces"
	"github.com/samber/lo"
)

// Workspaces is the resolver for the workspaces field.
func (r *meResolver) Workspaces(ctx context.Context, obj *gqlmodel.Me) ([]*gqlmodel.Workspace, error) {
	// If Workspaces is already set in the struct (from external API), use it
	if obj.Workspaces != nil {
		return obj.Workspaces, nil
	}
	return loaders(ctx).Workspace.FindByUser(ctx, obj.ID)
}

// MyWorkspace is the resolver for the myWorkspace field.
func (r *meResolver) MyWorkspace(ctx context.Context, obj *gqlmodel.Me) (*gqlmodel.Workspace, error) {
	// If MyWorkspace is already set in the struct (from external API), use it
	if obj.MyWorkspace != nil {
		return obj.MyWorkspace, nil
	}
	// Fallback to dataloader for backward compatibility
	return dataloaders(ctx).Workspace.Load(obj.MyWorkspaceID)
}

// Integrations is the resolver for the integrations field.
func (r *meResolver) Integrations(ctx context.Context, obj *gqlmodel.Me) ([]*gqlmodel.Integration, error) {
	return loaders(ctx).Integration.FindByMe(ctx)
}

// UpdateMe is the resolver for the updateMe field.
func (r *mutationResolver) UpdateMe(ctx context.Context, input gqlmodel.UpdateMeInput) (*gqlmodel.UpdateMePayload, error) {
	var theme *user.Theme
	if input.Theme != nil {
		theme = lo.ToPtr(user.ThemeFrom(input.Theme.String()))
	}
	res, err := usecases(ctx).User.UpdateMe(ctx, accountinterfaces.UpdateMeParam{
		Name:                 input.Name,
		Email:                input.Email,
		Lang:                 input.Lang,
		Theme:                theme,
		Password:             input.Password,
		PasswordConfirmation: input.PasswordConfirmation,
	}, getAcOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.UpdateMePayload{Me: gqlmodel.ToMe(res)}, nil
}

// RemoveMyAuth is the resolver for the removeMyAuth field.
func (r *mutationResolver) RemoveMyAuth(ctx context.Context, input gqlmodel.RemoveMyAuthInput) (*gqlmodel.UpdateMePayload, error) {
	res, err := usecases(ctx).User.RemoveMyAuth(ctx, input.Auth, getAcOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.UpdateMePayload{Me: gqlmodel.ToMe(res)}, nil
}

// DeleteMe is the resolver for the deleteMe field.
func (r *mutationResolver) DeleteMe(ctx context.Context, input gqlmodel.DeleteMeInput) (*gqlmodel.DeleteMePayload, error) {
	uid, err := gqlmodel.ToID[accountdomain.User](input.UserID)
	if err != nil {
		return nil, err
	}

	if err := usecases(ctx).User.DeleteMe(ctx, uid, getAcOperator(ctx)); err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteMePayload{UserID: input.UserID}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*gqlmodel.Me, error) {
	// Use external account API
	gateways := adapter.Gateways(ctx)
	if gateways == nil || gateways.Account == nil {
		// Fallback to local account data (for tests without external API configured)
		u := adapter.User(ctx)
		if u == nil {
			return nil, nil
		}
		return gqlmodel.ToMe(u), nil
	}

	extUser, err := gateways.Account.UserRepo.FindMe(ctx)
	if err != nil {
		return nil, err
	}

	if extUser == nil {
		return nil, nil
	}
	// Convert external user data to GraphQL model
	photoURL := extUser.Metadata().PhotoURL()

	// Convert MyWorkspace from our custom type to gqlmodel
	var myWorkspace *gqlmodel.Workspace
	if myWs := extUser.MyWorkspace(); !myWs.ID().IsEmpty() {
		myWorkspace = gqlmodel.ToWorkspaceFromValue(myWs)
	}
	// Convert workspaces list
	workspaces := gqlmodel.ToWorkspaces(extUser.Workspaces())

	return &gqlmodel.Me{
		ID:                gqlmodel.IDFrom(extUser.ID()),
		Name:              extUser.Name(),
		Email:             extUser.Email(),
		Lang:              extUser.Metadata().Lang(),
		Theme:             gqlmodel.Theme(extUser.Metadata().Theme()),
		Host:              extUser.Host(),
		MyWorkspaceID:     gqlmodel.ID(extUser.MyWorkspaceID().String()),
		Auths:             extUser.Auths(),
		ProfilePictureURL: &photoURL,
		MyWorkspace:       myWorkspace,
		Workspaces:        workspaces,
	}, nil
}

// UserSearch is the resolver for the userSearch field.
func (r *queryResolver) UserSearch(ctx context.Context, keyword string) ([]*gqlmodel.User, error) {
	return loaders(ctx).User.Search(ctx, keyword)
}

// UserByNameOrEmail is the resolver for the userByNameOrEmail field.
func (r *queryResolver) UserByNameOrEmail(ctx context.Context, nameOrEmail string) (*gqlmodel.User, error) {
	return loaders(ctx).User.ByNameOrEmail(ctx, nameOrEmail)
}

// Me returns MeResolver implementation.
func (r *Resolver) Me() MeResolver { return &meResolver{r} }

type meResolver struct{ *Resolver }
