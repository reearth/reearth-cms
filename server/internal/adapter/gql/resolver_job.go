package gql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/job"
	"github.com/reearth/reearthx/log"
	"github.com/samber/lo"
)

// CancelJob is the resolver for the cancelJob field.
func (r *mutationResolver) CancelJob(ctx context.Context, jobID gqlmodel.ID) (*gqlmodel.Job, error) {
	jid, err := gqlmodel.ToID[id.Job](jobID)
	if err != nil {
		return nil, err
	}

	j, err := usecases(ctx).Job.Cancel(ctx, jid, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return gqlmodel.ToJob(j), nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, jobID gqlmodel.ID) (*gqlmodel.Job, error) {
	jid, err := gqlmodel.ToID[id.Job](jobID)
	if err != nil {
		return nil, err
	}

	j, err := usecases(ctx).Job.FindByID(ctx, jid, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return gqlmodel.ToJob(j), nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context, projectID gqlmodel.ID, typeArg *gqlmodel.JobType, status *gqlmodel.JobStatus) ([]*gqlmodel.Job, error) {
	pid, err := gqlmodel.ToID[id.Project](projectID)
	if err != nil {
		return nil, err
	}

	jobs, err := usecases(ctx).Job.FindByProject(ctx, pid, gqlmodel.FromJobType(typeArg), gqlmodel.FromJobStatus(status), getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return lo.Map(jobs, func(j *job.Job, _ int) *gqlmodel.Job {
		return gqlmodel.ToJob(j)
	}), nil
}

// JobState is the resolver for the jobState field.
func (r *subscriptionResolver) JobState(ctx context.Context, jobID gqlmodel.ID) (<-chan *gqlmodel.JobState, error) {
	log.Infof("gql: websocket subscription started for job %s", jobID)

	jid, err := gqlmodel.ToID[id.Job](jobID)
	if err != nil {
		log.Errorf("gql: websocket subscription failed - invalid job ID %s: %v", jobID, err)
		return nil, err
	}

	stateCh, err := usecases(ctx).Job.Subscribe(ctx, jid, getOperator(ctx))
	if err != nil {
		log.Errorf("gql: websocket subscription failed for job %s: %v", jid, err)
		return nil, err
	}

	log.Debugf("gql: websocket subscription channel created for job %s", jid)

	// Create output channel that converts job.State to gqlmodel.JobState
	out := make(chan *gqlmodel.JobState, 10)

	go func() {
		defer func() {
			close(out)
			log.Infof("gql: websocket subscription closed for job %s", jid)
		}()
		messageCount := 0
		for {
			select {
			case <-ctx.Done():
				log.Debugf("gql: websocket subscription context cancelled for job %s (sent %d messages)", jid, messageCount)
				return
			case state, ok := <-stateCh:
				if !ok {
					log.Debugf("gql: websocket subscription source channel closed for job %s (sent %d messages)", jid, messageCount)
					return
				}
				messageCount++
				log.Debugf("gql: websocket sending message #%d for job %s: status=%s", messageCount, jid, state.Status)
				out <- gqlmodel.ToJobState(state)
			}
		}
	}()

	return out, nil
}
