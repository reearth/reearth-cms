package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/model"
	"github.com/samber/lo"
)

// Project is the resolver for the project field.
func (r *modelResolver) Project(ctx context.Context, obj *gqlmodel.Model) (*gqlmodel.Project, error) {
	return dataloaders(ctx).Project.Load(obj.ProjectID)
}

// Schema is the resolver for the schema field.
func (r *modelResolver) Schema(ctx context.Context, obj *gqlmodel.Model) (*gqlmodel.Schema, error) {
	return dataloaders(ctx).Schema.Load(obj.SchemaID)
}

// MetadataSchema is the resolver for the metadataSchema field.
func (r *modelResolver) MetadataSchema(ctx context.Context, obj *gqlmodel.Model) (*gqlmodel.Schema, error) {
	if obj.MetadataSchemaID == nil {
		return nil, nil
	}
	return dataloaders(ctx).Schema.Load(*obj.MetadataSchemaID)
}

// CreateModel is the resolver for the createModel field.
func (r *mutationResolver) CreateModel(ctx context.Context, input gqlmodel.CreateModelInput) (*gqlmodel.ModelPayload, error) {
	pId, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}
	res, err := usecases(ctx).Model.Create(ctx, interfaces.CreateModelParam{
		ProjectId:   pId,
		Name:        input.Name,
		Description: input.Description,
		Key:         input.Key,
		Public:      nil,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ModelPayload{
		Model: gqlmodel.ToModel(res),
	}, nil
}

// UpdateModel is the resolver for the updateModel field.
func (r *mutationResolver) UpdateModel(ctx context.Context, input gqlmodel.UpdateModelInput) (*gqlmodel.ModelPayload, error) {
	mId, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	res, err := usecases(ctx).Model.Update(ctx, interfaces.UpdateModelParam{
		ModelID:     mId,
		Name:        input.Name,
		Description: input.Description,
		Key:         input.Key,
		Public:      lo.ToPtr(input.Public),
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ModelPayload{
		Model: gqlmodel.ToModel(res),
	}, nil
}

// UpdateModelsOrder is the resolver for the updateModelsOrder field.
func (r *mutationResolver) UpdateModelsOrder(ctx context.Context, input gqlmodel.UpdateModelsOrderInput) (*gqlmodel.ModelsPayload, error) {
	mIds, err := gqlmodel.ToIDs[id.Model](input.ModelIds)
	if err != nil {
		return nil, err
	}
	models, err := usecases(ctx).Model.UpdateOrder(ctx, mIds, getOperator(ctx))
	if err != nil {
		return nil, err
	}
	return &gqlmodel.ModelsPayload{
		Models: lo.Map(models, func(mod *model.Model, _ int) *gqlmodel.Model {
			return gqlmodel.ToModel(mod)
		}),
	}, nil
}

// DeleteModel is the resolver for the deleteModel field.
func (r *mutationResolver) DeleteModel(ctx context.Context, input gqlmodel.DeleteModelInput) (*gqlmodel.DeleteModelPayload, error) {
	mid, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	err = usecases(ctx).Model.Delete(ctx, mid, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteModelPayload{
		ModelID: input.ModelID,
	}, nil
}

// PublishModel is the resolver for the publishModel field.
func (r *mutationResolver) PublishModel(ctx context.Context, input gqlmodel.PublishModelInput) (*gqlmodel.PublishModelPayload, error) {
	mid, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	param := interfaces.PublishModelParam{
		ModelID: mid,
		Public:  input.Status,
	}
	err = usecases(ctx).Model.Publish(ctx, []interfaces.PublishModelParam{param}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.PublishModelPayload{
		ModelID: input.ModelID,
		Status:  input.Status,
	}, nil
}

// PublishModels is the resolver for the publishModels field.
func (r *mutationResolver) PublishModels(ctx context.Context, input gqlmodel.PublishModelsInput) (*gqlmodel.PublishModelsPayload, error) {
	params := make([]interfaces.PublishModelParam, len(input.Models))
	for i, m := range input.Models {
		mid, err := gqlmodel.ToID[id.Model](m.ModelID)
		if err != nil {
			return nil, err
		}
		params[i] = interfaces.PublishModelParam{
			ModelID: mid,
			Public:  m.Status,
		}
	}

	err := usecases(ctx).Model.Publish(ctx, params, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.PublishModelsPayload{
		Models: lo.Map(input.Models, func(m *gqlmodel.PublishModelInput, _ int) *gqlmodel.PublishModelPayload {
			return &gqlmodel.PublishModelPayload{
				ModelID: m.ModelID,
				Status:  m.Status,
			}
		}),
	}, nil
}

// Models is the resolver for the models field.
func (r *queryResolver) Models(ctx context.Context, projectID gqlmodel.ID, pagination *gqlmodel.Pagination) (*gqlmodel.ModelConnection, error) {
	return loaders(ctx).Model.FindByProject(ctx, projectID, pagination)
}

// CheckModelKeyAvailability is the resolver for the checkModelKeyAvailability field.
func (r *queryResolver) CheckModelKeyAvailability(ctx context.Context, projectID gqlmodel.ID, key string) (*gqlmodel.KeyAvailability, error) {
	return loaders(ctx).Model.CheckKey(ctx, projectID, key)
}

// Model returns ModelResolver implementation.
func (r *Resolver) Model() ModelResolver { return &modelResolver{r} }

type modelResolver struct{ *Resolver }
