package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/url"

	"github.com/reearth/reearth-cms/server/internal/adapter"
	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/exporters"
	"github.com/reearth/reearth-cms/server/pkg/file"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/model"
	"github.com/samber/lo"
)

// Project is the resolver for the project field.
func (r *modelResolver) Project(ctx context.Context, obj *gqlmodel.Model) (*gqlmodel.Project, error) {
	return dataloaders(ctx).Project.Load(obj.ProjectID)
}

// Schema is the resolver for the schema field.
func (r *modelResolver) Schema(ctx context.Context, obj *gqlmodel.Model) (*gqlmodel.Schema, error) {
	return dataloaders(ctx).Schema.Load(obj.SchemaID)
}

// MetadataSchema is the resolver for the metadataSchema field.
func (r *modelResolver) MetadataSchema(ctx context.Context, obj *gqlmodel.Model) (*gqlmodel.Schema, error) {
	if obj.MetadataSchemaID == nil {
		return nil, nil
	}
	return dataloaders(ctx).Schema.Load(*obj.MetadataSchemaID)
}

// CreateModel is the resolver for the createModel field.
func (r *mutationResolver) CreateModel(ctx context.Context, input gqlmodel.CreateModelInput) (*gqlmodel.ModelPayload, error) {
	pId, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}
	res, err := usecases(ctx).Model.Create(ctx, interfaces.CreateModelParam{
		ProjectId:   pId,
		Name:        input.Name,
		Description: input.Description,
		Key:         input.Key,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ModelPayload{
		Model: gqlmodel.ToModel(res),
	}, nil
}

// UpdateModel is the resolver for the updateModel field.
func (r *mutationResolver) UpdateModel(ctx context.Context, input gqlmodel.UpdateModelInput) (*gqlmodel.ModelPayload, error) {
	mId, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	res, err := usecases(ctx).Model.Update(ctx, interfaces.UpdateModelParam{
		ModelID:     mId,
		Name:        input.Name,
		Description: input.Description,
		Key:         input.Key,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ModelPayload{
		Model: gqlmodel.ToModel(res),
	}, nil
}

// UpdateModelsOrder is the resolver for the updateModelsOrder field.
func (r *mutationResolver) UpdateModelsOrder(ctx context.Context, input gqlmodel.UpdateModelsOrderInput) (*gqlmodel.ModelsPayload, error) {
	mIds, err := gqlmodel.ToIDs[id.Model](input.ModelIds)
	if err != nil {
		return nil, err
	}
	models, err := usecases(ctx).Model.UpdateOrder(ctx, mIds, getOperator(ctx))
	if err != nil {
		return nil, err
	}
	return &gqlmodel.ModelsPayload{
		Models: lo.Map(models, func(mod *model.Model, _ int) *gqlmodel.Model {
			return gqlmodel.ToModel(mod)
		}),
	}, nil
}

// DeleteModel is the resolver for the deleteModel field.
func (r *mutationResolver) DeleteModel(ctx context.Context, input gqlmodel.DeleteModelInput) (*gqlmodel.DeleteModelPayload, error) {
	mid, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	err = usecases(ctx).Model.Delete(ctx, mid, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteModelPayload{
		ModelID: input.ModelID,
	}, nil
}

// ExportModel is the resolver for the exportModel field.
func (r *mutationResolver) ExportModel(ctx context.Context, input gqlmodel.ExportModelInput) (*gqlmodel.ExportModelPayload, error) {
	op, uc, g := adapter.Operator(ctx), adapter.Usecases(ctx), adapter.Gateways(ctx)

	mId, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	m, err := uc.Model.FindByID(ctx, mId, op)
	if err != nil {
		return nil, err
	}

	sp, err := uc.Schema.FindByModel(ctx, mId, op)
	if err != nil {
		return nil, err
	}

	format := gqlmodel.ToExportFormat(input.Format)

	w := bytes.NewBuffer(nil)
	err = uc.Item.Export(ctx, interfaces.ExportItemParams{
		Format:        format,
		ModelID:       mId,
		SchemaPackage: *sp,
		Options: exporters.ExportOptions{
			PublicOnly: true,
		},
	}, w, op)
	if err != nil {
		return nil, err
	}

	ext := ".json"
	ct := "application/json"
	if format == exporters.FormatGeoJSON {
		ext = ".geojson"
		ct = "application/geo+json"
	}

	// upload result as file
	_, err = g.File.Upload(ctx, &file.File{
		Content:         io.NopCloser(w),
		Name:            m.ID().String() + ext,
		Size:            int64(w.Len()),
		ContentType:     ct,
		ContentEncoding: "",
	}, m.ID().String()+ext)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ExportModelPayload{
		URL: *lo.Must(url.Parse(g.File.GetBaseURL())).JoinPath(m.ID().String() + ext),
	}, nil
}

// ExportModelSchema is the resolver for the exportModelSchema field.
func (r *mutationResolver) ExportModelSchema(ctx context.Context, input gqlmodel.ExportModelSchemaInput) (*gqlmodel.ExportModelSchemaPayload, error) {
	op, uc, g := adapter.Operator(ctx), adapter.Usecases(ctx), adapter.Gateways(ctx)

	mId, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	m, err := uc.Model.FindByID(ctx, mId, op)
	if err != nil {
		return nil, err
	}

	js, err := uc.Schema.Export(ctx, interfaces.ExportSchemaParam{
		ModelID: mId,
		Target:  interfaces.SchemaExportTargetSchema,
	}, op)
	if err != nil {
		return nil, err
	}

	fileName := fmt.Sprintf("%s.schema.json", m.Key())
	data, err := json.MarshalIndent(js, "", "  ")
	if err != nil {
		return nil, err
	}
	// upload result as file
	_, err = g.File.Upload(ctx, &file.File{
		Content:         io.NopCloser(bytes.NewReader(data)),
		Name:            fileName,
		Size:            int64(len(data)),
		ContentType:     "application/json",
		ContentEncoding: "",
	}, fileName)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ExportModelSchemaPayload{
		URL: *lo.Must(url.Parse(g.File.GetBaseURL())).JoinPath(fileName),
	}, nil
}

// Models is the resolver for the models field.
func (r *queryResolver) Models(ctx context.Context, projectID gqlmodel.ID, keyword *string, sort *gqlmodel.Sort, pagination *gqlmodel.Pagination) (*gqlmodel.ModelConnection, error) {
	return loaders(ctx).Model.FindByProject(ctx, projectID, keyword, sort, pagination)
}

// CheckModelKeyAvailability is the resolver for the checkModelKeyAvailability field.
func (r *queryResolver) CheckModelKeyAvailability(ctx context.Context, projectID gqlmodel.ID, key string) (*gqlmodel.KeyAvailability, error) {
	return loaders(ctx).Model.CheckKey(ctx, projectID, key)
}

// Model returns ModelResolver implementation.
func (r *Resolver) Model() ModelResolver { return &modelResolver{r} }

type modelResolver struct{ *Resolver }
