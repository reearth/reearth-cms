package gql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"strings"

	"github.com/google/uuid"
	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/item"
	"github.com/reearth/reearth-cms/server/pkg/value"
	"github.com/reearth/reearth-cms/server/pkg/version"
	"github.com/reearth/reearthx/util"
	"github.com/samber/lo"
)

// CreatedBy is the resolver for the createdBy field.
func (r *itemResolver) CreatedBy(ctx context.Context, obj *gqlmodel.Item) (gqlmodel.Operator, error) {
	if obj.UserID != nil {
		return dataloaders(ctx).User.Load(*obj.UserID)
	}
	return dataloaders(ctx).Integration.Load(*obj.IntegrationID)
}

// Schema is the resolver for the schema field.
func (r *itemResolver) Schema(ctx context.Context, obj *gqlmodel.Item) (*gqlmodel.Schema, error) {
	return dataloaders(ctx).Schema.Load(obj.SchemaID)
}

// Model is the resolver for the model field.
func (r *itemResolver) Model(ctx context.Context, obj *gqlmodel.Item) (*gqlmodel.Model, error) {
	return dataloaders(ctx).Model.Load(obj.ModelID)
}

// Status is the resolver for the status field.
func (r *itemResolver) Status(ctx context.Context, obj *gqlmodel.Item) (gqlmodel.ItemStatus, error) {
	res, err := dataloaders(ctx).ItemStatus.Load(obj.ID)
	return *res, err
}

// Project is the resolver for the project field.
func (r *itemResolver) Project(ctx context.Context, obj *gqlmodel.Item) (*gqlmodel.Project, error) {
	return dataloaders(ctx).Project.Load(obj.ProjectID)
}

// Thread is the resolver for the thread field.
func (r *itemResolver) Thread(ctx context.Context, obj *gqlmodel.Item) (*gqlmodel.Thread, error) {
	if obj.ThreadID == nil {
		return nil, nil
	}
	return dataloaders(ctx).Thread.Load(*obj.ThreadID)
}

// Assets is the resolver for the assets field.
func (r *itemResolver) Assets(ctx context.Context, obj *gqlmodel.Item) ([]*gqlmodel.Asset, error) {
	aIds := lo.FlatMap(obj.Fields, func(f *gqlmodel.ItemField, _ int) []gqlmodel.ID {
		if f.Type != gqlmodel.SchemaFieldTypeAsset || f.Value == nil {
			return nil
		}
		if s, ok := f.Value.(string); ok {
			return []gqlmodel.ID{gqlmodel.ID(s)}
		}
		if ss, ok := f.Value.([]any); ok {
			return lo.FilterMap(ss, func(i any, _ int) (gqlmodel.ID, bool) {
				if str, ok := i.(string); ok {
					return gqlmodel.ID(str), ok
				}
				return "", false
			})
		}
		return nil
	})

	assets, err := dataloaders(ctx).Asset.LoadAll(aIds)
	if len(err) > 0 && err[0] != nil {
		return nil, err[0]
	}
	return assets, nil
}

// ReferencedItems is the resolver for the referencedItems field.
func (r *itemResolver) ReferencedItems(ctx context.Context, obj *gqlmodel.Item) ([]*gqlmodel.Item, error) {
	refIds := lo.FlatMap(obj.Fields, func(f *gqlmodel.ItemField, _ int) []gqlmodel.ID {
		if f.Type != gqlmodel.SchemaFieldTypeReference || f.Value == nil {
			return nil
		}
		if s, ok := f.Value.(string); ok {
			return []gqlmodel.ID{gqlmodel.ID(s)}
		}
		if ss, ok := f.Value.([]any); ok {
			return lo.FilterMap(ss, func(i any, _ int) (gqlmodel.ID, bool) {
				if str, ok := i.(string); ok {
					return gqlmodel.ID(str), ok
				}
				return "", false
			})
		}
		return nil
	})

	refItems, err := dataloaders(ctx).Item.LoadAll(refIds)
	if len(err) > 0 && err[0] != nil {
		return nil, err[0]
	}
	return lo.Filter(refItems, func(item *gqlmodel.Item, _ int) bool {
		return item != nil
	}), nil
}

// Requests is the resolver for the requests field.
func (r *itemResolver) Requests(ctx context.Context, obj *gqlmodel.Item) ([]*gqlmodel.Request, error) {
	return loaders(ctx).Request.FindByItem(ctx, obj.ID)
}

// UpdatedBy is the resolver for the updatedBy field.
func (r *itemResolver) UpdatedBy(ctx context.Context, obj *gqlmodel.Item) (gqlmodel.Operator, error) {
	if obj.UpdatedByUserID != nil {
		return dataloaders(ctx).User.Load(*obj.UpdatedByUserID)
	}
	if obj.UpdatedByIntegrationID != nil {
		return dataloaders(ctx).Integration.Load(*obj.UpdatedByIntegrationID)
	}
	return nil, nil
}

// Metadata is the resolver for the metadata field.
func (r *itemResolver) Metadata(ctx context.Context, obj *gqlmodel.Item) (*gqlmodel.Item, error) {
	if obj.MetadataID == nil {
		return nil, nil
	}
	return dataloaders(ctx).Item.Load(*obj.MetadataID)
}

// Original is the resolver for the original field.
func (r *itemResolver) Original(ctx context.Context, obj *gqlmodel.Item) (*gqlmodel.Item, error) {
	if obj.OriginalID == nil {
		return nil, nil
	}
	return dataloaders(ctx).Item.Load(*obj.OriginalID)
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input gqlmodel.CreateItemInput) (*gqlmodel.ItemPayload, error) {
	op := getOperator(ctx)
	sid, err := gqlmodel.ToID[id.Schema](input.SchemaID)
	if err != nil {
		return nil, err
	}
	mid, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}
	m, err := usecases(ctx).Model.FindByID(ctx, mid, op)
	if err != nil {
		return nil, err
	}

	ss, gs, err := usecases(ctx).Schema.GetSchemasAndGroupSchemasByIDs(ctx, id.SchemaIDList{m.Schema()}, op)
	if err != nil {
		return nil, err
	}
	res, err := usecases(ctx).Item.Create(ctx, interfaces.CreateItemParam{
		SchemaID:   sid,
		ModelID:    mid,
		MetadataID: gqlmodel.ToIDRef[id.Item](input.MetadataID),
		Fields:     util.DerefSlice(util.Map(input.Fields, gqlmodel.ToItemParam)),
	}, op)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ItemPayload{
		Item: gqlmodel.ToItem(res, ss[0], gs),
	}, nil
}

// UpdateItem is the resolver for the updateItem field.
func (r *mutationResolver) UpdateItem(ctx context.Context, input gqlmodel.UpdateItemInput) (*gqlmodel.ItemPayload, error) {
	op := getOperator(ctx)
	iid, err := gqlmodel.ToID[id.Item](input.ItemID)
	if err != nil {
		return nil, err
	}

	var v version.Version
	if input.Version != nil {
		u, err := uuid.Parse(*input.Version)
		if err != nil {
			return nil, err
		}
		v = version.Version(u)
	}

	res, err := usecases(ctx).Item.Update(ctx, interfaces.UpdateItemParam{
		ItemID:     iid,
		MetadataID: gqlmodel.ToIDRef[id.Item](input.MetadataID),
		Fields:     util.DerefSlice(util.Map(input.Fields, gqlmodel.ToItemParam)),
		Version:    &v,
	}, op)
	if err != nil {
		return nil, err
	}

	ss, gs, err := usecases(ctx).Schema.GetSchemasAndGroupSchemasByIDs(ctx, id.SchemaIDList{res.Value().Schema()}, op)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ItemPayload{
		Item: gqlmodel.ToItem(res, ss[0], gs),
	}, nil
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, input gqlmodel.DeleteItemInput) (*gqlmodel.DeleteItemPayload, error) {
	iid, err := gqlmodel.ToID[id.Item](input.ItemID)
	if err != nil {
		return nil, err
	}

	i, err := usecases(ctx).Item.FindByID(ctx, iid, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	sp, err := usecases(ctx).Schema.FindByModel(ctx, i.Value().Model(), getOperator(ctx))
	if err != nil {
		return nil, err
	}

	if err := usecases(ctx).Item.Delete(ctx, iid, *sp, getOperator(ctx)); err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteItemPayload{ItemID: input.ItemID}, nil
}

// DeleteItems is the resolver for the deleteItems field.
func (r *mutationResolver) DeleteItems(ctx context.Context, input gqlmodel.DeleteItemsInput) (*gqlmodel.DeleteItemsPayload, error) {
	itemIDs, err := gqlmodel.ToIDs[id.Item](input.ItemIds)
	if err != nil {
		return nil, err
	}

	i, err := usecases(ctx).Item.FindByID(ctx, itemIDs[0], getOperator(ctx))
	if err != nil {
		return nil, err
	}

	sp, err := usecases(ctx).Schema.FindByModel(ctx, i.Value().Model(), getOperator(ctx))
	if err != nil {
		return nil, err
	}

	deletedIDs, err := usecases(ctx).Item.BatchDelete(ctx, itemIDs, *sp, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	// Convert deleted IDs to gqlmodel.ID format
	result := make([]gqlmodel.ID, 0, len(deletedIDs))
	for _, itemID := range deletedIDs {
		result = append(result, gqlmodel.IDFrom(itemID))
	}

	return &gqlmodel.DeleteItemsPayload{ItemIds: result}, nil
}

// PublishItem is the resolver for the publishItem field.
func (r *mutationResolver) PublishItem(ctx context.Context, input gqlmodel.PublishItemInput) (*gqlmodel.PublishItemPayload, error) {
	op := getOperator(ctx)

	iid, err := gqlmodel.ToIDs[id.Item](input.ItemIds)
	if err != nil {
		return nil, err
	}
	itm, err := usecases(ctx).Item.Publish(ctx, iid, op)
	if err != nil {
		return nil, err
	}
	s, err := usecases(ctx).Schema.FindByID(ctx, itm[0].Value().Schema(), op)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.PublishItemPayload{
		Items: lo.Map(itm, func(t item.Versioned, _ int) *gqlmodel.Item { return gqlmodel.ToItem(t, s, nil) }),
	}, nil
}

// UnpublishItem is the resolver for the unpublishItem field.
func (r *mutationResolver) UnpublishItem(ctx context.Context, input gqlmodel.UnpublishItemInput) (*gqlmodel.UnpublishItemPayload, error) {
	op := getOperator(ctx)
	iid, err := gqlmodel.ToIDs[id.Item](input.ItemIds)
	if err != nil {
		return nil, err
	}
	res, err := usecases(ctx).Item.Unpublish(ctx, iid, op)
	if err != nil {
		return nil, err
	}
	s, err := usecases(ctx).Schema.FindByID(ctx, res[0].Value().Schema(), op)
	if err != nil {
		return nil, err
	}
	return &gqlmodel.UnpublishItemPayload{
		Items: lo.Map(res, func(t item.Versioned, _ int) *gqlmodel.Item { return gqlmodel.ToItem(t, s, nil) }),
	}, nil
}

// ImportItems is the resolver for the importItems field.
func (r *mutationResolver) ImportItems(ctx context.Context, input gqlmodel.ImportItemsInput) (*gqlmodel.ImportItemsPayload, error) {
	op := getOperator(ctx)

	// Validate file size (max 10MB)
	if input.File.Size > interfaces.MaxImportFileSize {
		return nil, interfaces.ErrImportFileTooLarge
	}

	mid, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	sp, err := usecases(ctx).Schema.FindByModel(ctx, mid, op)
	if err != nil {
		return nil, err
	}

	// Detect format from filename
	format := interfaces.ImportFormatTypeJSON
	if strings.HasSuffix(strings.ToLower(input.File.Filename), ".geojson") {
		format = interfaces.ImportFormatTypeGeoJSON
	} else if strings.HasSuffix(strings.ToLower(input.File.Filename), ".csv") {
		format = interfaces.ImportFormatTypeCSV
	}

	// Auto-detect first geometry field for GeoJSON import when geoField is not specified
	geoField := input.GeoField
	if format == interfaces.ImportFormatTypeGeoJSON && geoField == nil {
		geoFields := sp.Schema().FieldsByType(value.TypeGeometryObject)
		if len(geoFields) > 0 {
			key := geoFields[0].Key().String()
			geoField = &key
		}
	}

	res, err := usecases(ctx).Item.Import(ctx, interfaces.ImportItemsParam{
		ModelID:      mid,
		SP:           *sp,
		Strategy:     interfaces.ImportStrategyTypeInsert,
		Format:       format,
		MutateSchema: false,
		Reader:       input.File.File,
		GeoField:     geoField,
	}, op)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ImportItemsPayload{
		ModelID:       input.ModelID,
		TotalCount:    res.Total,
		InsertedCount: res.Inserted,
		UpdatedCount:  res.Updated,
		IgnoredCount:  res.Ignored,
	}, nil
}

// ImportItemsAsync is the resolver for the importItemsAsync field.
func (r *mutationResolver) ImportItemsAsync(ctx context.Context, input gqlmodel.ImportItemsInput) (*gqlmodel.ImportItemsAsyncPayload, error) {
	op := getOperator(ctx)

	// Validate file size (max 10MB)
	if input.File.Size > interfaces.MaxImportFileSize {
		return nil, interfaces.ErrImportFileTooLarge
	}

	mid, err := gqlmodel.ToID[id.Model](input.ModelID)
	if err != nil {
		return nil, err
	}

	sp, err := usecases(ctx).Schema.FindByModel(ctx, mid, op)
	if err != nil {
		return nil, err
	}

	// Detect format from filename
	format := interfaces.ImportFormatTypeJSON
	if strings.HasSuffix(strings.ToLower(input.File.Filename), ".geojson") {
		format = interfaces.ImportFormatTypeGeoJSON
	} else if strings.HasSuffix(strings.ToLower(input.File.Filename), ".csv") {
		format = interfaces.ImportFormatTypeCSV
	}

	// Auto-detect first geometry field for GeoJSON import when geoField is not specified
	geoField := input.GeoField
	if format == interfaces.ImportFormatTypeGeoJSON && geoField == nil {
		geoFields := sp.Schema().FieldsByType(value.TypeGeometryObject)
		if len(geoFields) > 0 {
			key := geoFields[0].Key().String()
			geoField = &key
		}
	}

	jobID, err := usecases(ctx).Item.ImportAsync(ctx, interfaces.ImportItemsAsyncParam{
		ModelID:      mid,
		SP:           *sp,
		Strategy:     interfaces.ImportStrategyTypeInsert,
		Format:       format,
		MutateSchema: false,
		Reader:       input.File.File,
		GeoField:     geoField,
	}, op)
	if err != nil {
		return nil, err
	}

	// Fetch the created job to return
	j, err := usecases(ctx).Job.FindByID(ctx, jobID, op)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ImportItemsAsyncPayload{
		Job: gqlmodel.ToJob(j),
	}, nil
}

// VersionsByItem is the resolver for the versionsByItem field.
func (r *queryResolver) VersionsByItem(ctx context.Context, itemID gqlmodel.ID) ([]*gqlmodel.VersionedItem, error) {
	return loaders(ctx).Item.FindVersionedItems(ctx, itemID)
}

// SearchItem is the resolver for the searchItem field.
func (r *queryResolver) SearchItem(ctx context.Context, input gqlmodel.SearchItemInput) (*gqlmodel.ItemConnection, error) {
	return loaders(ctx).Item.Search(ctx, input)
}

// IsItemReferenced is the resolver for the isItemReferenced field.
func (r *queryResolver) IsItemReferenced(ctx context.Context, itemID gqlmodel.ID, correspondingFieldID gqlmodel.ID) (bool, error) {
	return loaders(ctx).Item.IsItemReferenced(ctx, itemID, correspondingFieldID)
}

// Item returns ItemResolver implementation.
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

type itemResolver struct{ *Resolver }
