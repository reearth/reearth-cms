package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/integration"
)

// Developer is the resolver for the developer field.
func (r *integrationResolver) Developer(ctx context.Context, obj *gqlmodel.Integration) (*gqlmodel.User, error) {
	return dataloaders(ctx).User.Load(obj.DeveloperID)
}

// CreateIntegration is the resolver for the createIntegration field.
func (r *mutationResolver) CreateIntegration(ctx context.Context, input gqlmodel.CreateIntegrationInput) (*gqlmodel.IntegrationPayload, error) {
	op := getOperator(ctx)

	res, err := usecases(ctx).Integration.Create(
		ctx,
		interfaces.CreateIntegrationParam{
			Name:        input.Name,
			Description: input.Description,
			Type:        integration.TypeFrom(input.Type.String()),
			Logo:        input.LogoURL,
		},
		op,
	)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.IntegrationPayload{
		Integration: gqlmodel.ToIntegration(res, op.AcOperator.User),
	}, nil
}

// UpdateIntegration is the resolver for the updateIntegration field.
func (r *mutationResolver) UpdateIntegration(ctx context.Context, input gqlmodel.UpdateIntegrationInput) (*gqlmodel.IntegrationPayload, error) {
	iId, err := gqlmodel.ToID[id.Integration](input.IntegrationID)
	if err != nil {
		return nil, err
	}
	op := getOperator(ctx)

	res, err := usecases(ctx).Integration.Update(
		ctx,
		iId,
		interfaces.UpdateIntegrationParam{
			Name:        input.Name,
			Description: input.Description,
			Logo:        input.LogoURL,
		},
		op,
	)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.IntegrationPayload{
		Integration: gqlmodel.ToIntegration(res, op.AcOperator.User),
	}, nil
}

// DeleteIntegration is the resolver for the deleteIntegration field.
func (r *mutationResolver) DeleteIntegration(ctx context.Context, input gqlmodel.DeleteIntegrationInput) (*gqlmodel.DeleteIntegrationPayload, error) {
	iId, err := gqlmodel.ToID[id.Integration](input.IntegrationID)
	if err != nil {
		return nil, err
	}

	err = usecases(ctx).Integration.Delete(ctx, iId, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteIntegrationPayload{
		IntegrationID: input.IntegrationID,
	}, nil
}

// RegenerateIntegrationToken is the resolver for the regenerateToken field.
func (r *mutationResolver) RegenerateIntegrationToken(ctx context.Context, input gqlmodel.RegenerateIntegrationTokenInput) (*gqlmodel.IntegrationPayload, error) {
	iId, err := gqlmodel.ToID[id.Integration](input.IntegrationID)
	if err != nil {
		return nil, err
	}

	op := getOperator(ctx)
	res, err := usecases(ctx).Integration.RegenerateToken(ctx, iId, op)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.IntegrationPayload{
		Integration: gqlmodel.ToIntegration(res, op.AcOperator.User),
	}, nil
}

// Integration returns IntegrationResolver implementation.
func (r *Resolver) Integration() IntegrationResolver { return &integrationResolver{r} }

type integrationResolver struct{ *Resolver }
