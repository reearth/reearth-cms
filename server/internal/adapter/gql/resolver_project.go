package gql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearthx/account/accountdomain"
	"github.com/reearth/reearthx/account/accountdomain/workspace"
	"github.com/samber/lo"
)

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input gqlmodel.CreateProjectInput) (*gqlmodel.ProjectPayload, error) {
	wid, err := gqlmodel.ToID[accountdomain.Workspace](input.WorkspaceID)
	if err != nil {
		return nil, err
	}

	params := interfaces.CreateProjectParam{
		WorkspaceID:  wid,
		Name:         input.Name,
		Description:  input.Description,
		License:      input.License,
		Readme:       input.Readme,
		Alias:        input.Alias,
		RequestRoles: lo.Map(input.RequestRoles, func(r gqlmodel.Role, _ int) workspace.Role { return workspace.Role(r) }),
	}
	if input.Visibility != nil {
		params.Accessibility = &interfaces.AccessibilityParam{
			Visibility: gqlmodel.FromProjectVisibility(input.Visibility),
		}
	}
	res, err := usecases(ctx).Project.Create(ctx, params, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ProjectPayload{Project: gqlmodel.ToProject(res)}, nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, input gqlmodel.UpdateProjectInput) (*gqlmodel.ProjectPayload, error) {
	pid, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	var pub *interfaces.AccessibilityParam
	if input.Accessibility != nil {
		pub = &interfaces.AccessibilityParam{
			Visibility:  gqlmodel.FromProjectVisibility(input.Accessibility.Visibility),
			Publication: gqlmodel.FromPublicationSettings(input.Accessibility.Publication),
		}
	}

	res, err := usecases(ctx).Project.Update(ctx, interfaces.UpdateProjectParam{
		ID:            pid,
		Name:          input.Name,
		Description:   input.Description,
		License:       input.License,
		Readme:        input.Readme,
		Alias:         input.Alias,
		Accessibility: pub,
		RequestRoles:  lo.Map(input.RequestRoles, func(r gqlmodel.Role, _ int) workspace.Role { return gqlmodel.FromRole(r) }),
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.ProjectPayload{Project: gqlmodel.ToProject(res)}, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, input gqlmodel.DeleteProjectInput) (*gqlmodel.DeleteProjectPayload, error) {
	pid, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	if err := usecases(ctx).Project.Delete(ctx, pid, getOperator(ctx)); err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteProjectPayload{ProjectID: input.ProjectID}, nil
}

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, input gqlmodel.CreateAPIKeyInput) (*gqlmodel.APIKeyPayload, error) {
	pId, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	pub := gqlmodel.FromPublicationSettings(input.Publication)
	if pub == nil {
		pub = &interfaces.PublicationSettingsParam{
			PublicModels: nil,
			PublicAssets: false,
		}
	}

	p, keyId, err := usecases(ctx).Project.CreateAPIKey(ctx, interfaces.CreateAPITokenParam{
		ProjectID:   pId,
		Name:        input.Name,
		Description: input.Description,
		Publication: *pub,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return gqlmodel.ToAPIKeyPayload(p, *keyId), nil
}

// UpdateAPIKey is the resolver for the updateAPIKey field.
func (r *mutationResolver) UpdateAPIKey(ctx context.Context, input gqlmodel.UpdateAPIKeyInput) (*gqlmodel.APIKeyPayload, error) {
	pId, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	kId, err := gqlmodel.ToID[id.APIKey](input.ID)
	if err != nil {
		return nil, err
	}

	p, err := usecases(ctx).Project.UpdateAPIKey(ctx, interfaces.UpdateAPITokenParam{
		ProjectID:   pId,
		TokenId:     kId,
		Name:        input.Name,
		Description: input.Description,
		Publication: gqlmodel.FromPublicationSettings(input.Publication),
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return gqlmodel.ToAPIKeyPayload(p, kId), nil
}

// DeleteAPIKey is the resolver for the deleteAPIKey field.
func (r *mutationResolver) DeleteAPIKey(ctx context.Context, input gqlmodel.DeleteAPIKeyInput) (*gqlmodel.DeleteAPIKeyPayload, error) {
	kId, err := gqlmodel.ToID[id.APIKey](input.ID)
	if err != nil {
		return nil, err
	}

	pId, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	_, err = usecases(ctx).Project.DeleteAPIKey(ctx, pId, kId, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteAPIKeyPayload{
		APIKeyID: input.ID,
	}, nil
}

// RegenerateAPIKey is the resolver for the regenerateAPIKey field.
func (r *mutationResolver) RegenerateAPIKey(ctx context.Context, input gqlmodel.RegenerateAPIKeyInput) (*gqlmodel.APIKeyPayload, error) {
	kId, err := gqlmodel.ToID[id.APIKey](input.ID)
	if err != nil {
		return nil, err
	}

	pId, err := gqlmodel.ToID[id.Project](input.ProjectID)
	if err != nil {
		return nil, err
	}

	p, err := usecases(ctx).Project.RegenerateAPIKeyKey(ctx, interfaces.RegenerateKeyParam{
		ProjectId: pId,
		KeyId:     kId,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return gqlmodel.ToAPIKeyPayload(p, kId), nil
}

// Workspace is the resolver for the workspace field.
func (r *projectResolver) Workspace(ctx context.Context, obj *gqlmodel.Project) (*gqlmodel.Workspace, error) {
	return dataloaders(ctx).Workspace.Load(obj.WorkspaceID)
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, workspaceID gqlmodel.ID, keyword *string, sort *gqlmodel.Sort, pagination *gqlmodel.Pagination) (*gqlmodel.ProjectConnection, error) {
	return loaders(ctx).Project.FindByWorkspace(ctx, workspaceID, keyword, sort, pagination)
}

// CheckProjectAlias is the resolver for the checkProjectAlias field.
func (r *queryResolver) CheckProjectAlias(ctx context.Context, workspaceID gqlmodel.ID, alias string) (*gqlmodel.ProjectAliasAvailability, error) {
	return loaders(ctx).Project.CheckAlias(ctx, workspaceID, alias)
}

// CheckWorkspaceProjectLimits is the resolver for the checkWorkspaceProjectLimits field.
func (r *queryResolver) CheckWorkspaceProjectLimits(ctx context.Context, workspaceID gqlmodel.ID) (*gqlmodel.WorkspaceProjectLimits, error) {
	return loaders(ctx).Project.CheckWorkspaceProjectLimits(ctx, workspaceID)
}

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

type projectResolver struct{ *Resolver }
