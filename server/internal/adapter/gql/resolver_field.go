package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"

	"github.com/reearth/reearth-cms/server/internal/adapter/gql/gqlmodel"
	"github.com/reearth/reearth-cms/server/internal/usecase/interfaces"
	"github.com/reearth/reearth-cms/server/pkg/id"
	"github.com/reearth/reearth-cms/server/pkg/schema"
	"github.com/reearth/reearthx/util"
	"github.com/samber/lo"
)

// CreateField is the resolver for the createField field.
func (r *mutationResolver) CreateField(ctx context.Context, input gqlmodel.CreateFieldInput) (*gqlmodel.FieldPayload, error) {
	mid := gqlmodel.ToIDRef[id.Model](input.ModelID)
	gid := gqlmodel.ToIDRef[id.Group](input.GroupID)
	param := interfaces.FindOrCreateSchemaParam{
		ModelID:  mid,
		GroupID:  gid,
		Metadata: input.Metadata,
		Create:   true,
	}
	s, err := usecases(ctx).Model.FindOrCreateSchema(ctx, param, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	tp, dv, err := gqlmodel.FromSchemaTypeProperty(input.TypeProperty, input.Type, input.Multiple)
	if err != nil {
		return nil, err
	}

	f, err := usecases(ctx).Schema.CreateField(ctx, interfaces.CreateFieldParam{
		ModelID:      mid,
		SchemaID:     s.ID(),
		Type:         gqlmodel.FromValueType(input.Type),
		Name:         input.Title,
		Description:  input.Description,
		Key:          input.Key,
		Multiple:     input.Multiple,
		Unique:       input.Unique,
		Required:     input.Required,
		IsTitle:      input.IsTitle,
		DefaultValue: dv,
		TypeProperty: tp,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.FieldPayload{
		Field: gqlmodel.ToSchemaField(f, s.TitleField()),
	}, nil
}

// UpdateField is the resolver for the updateField field.
func (r *mutationResolver) UpdateField(ctx context.Context, input gqlmodel.UpdateFieldInput) (*gqlmodel.FieldPayload, error) {
	fid, err := gqlmodel.ToID[id.Field](input.FieldID)
	if err != nil {
		return nil, err
	}

	mid := gqlmodel.ToIDRef[id.Model](input.ModelID)
	gid := gqlmodel.ToIDRef[id.Group](input.GroupID)
	param := interfaces.FindOrCreateSchemaParam{
		ModelID:  mid,
		GroupID:  gid,
		Metadata: input.Metadata,
		Create:   true,
	}
	s, err := usecases(ctx).Model.FindOrCreateSchema(ctx, param, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	dbField := s.Field(fid)

	tp, dv, err := gqlmodel.FromSchemaTypeProperty(input.TypeProperty, gqlmodel.ToValueType(dbField.Type()), lo.FromPtrOr(input.Multiple, dbField.Multiple()))
	if err != nil {
		return nil, err
	}

	f, err := usecases(ctx).Schema.UpdateField(ctx, interfaces.UpdateFieldParam{
		ModelID:      mid,
		SchemaID:     s.ID(),
		FieldID:      fid,
		Name:         input.Title,
		Description:  input.Description,
		Key:          input.Key,
		Multiple:     input.Multiple,
		Order:        input.Order,
		Unique:       input.Unique,
		Required:     input.Required,
		IsTitle:      input.IsTitle,
		DefaultValue: dv,
		TypeProperty: tp,
	}, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.FieldPayload{
		Field: gqlmodel.ToSchemaField(f, s.TitleField()),
	}, nil
}

// UpdateFields is the resolver for the updateFields field.
func (r *mutationResolver) UpdateFields(ctx context.Context, input []*gqlmodel.UpdateFieldInput) (*gqlmodel.FieldsPayload, error) {
	mid := gqlmodel.ToIDRef[id.Model](input[0].ModelID)
	gid := gqlmodel.ToIDRef[id.Group](input[0].GroupID)
	param := interfaces.FindOrCreateSchemaParam{
		ModelID:  mid,
		GroupID:  gid,
		Metadata: input[0].Metadata,
		Create:   true,
	}
	s, err := usecases(ctx).Model.FindOrCreateSchema(ctx, param, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	params, err := util.TryMap(input, func(ipt *gqlmodel.UpdateFieldInput) (interfaces.UpdateFieldParam, error) {
		fid, err := gqlmodel.ToID[id.Field](ipt.FieldID)
		if err != nil {
			return interfaces.UpdateFieldParam{}, err
		}
		dbField := s.Field(fid)

		tp, dv, err := gqlmodel.FromSchemaTypeProperty(ipt.TypeProperty, gqlmodel.ToValueType(dbField.Type()), dbField.Multiple())
		if err != nil {
			return interfaces.UpdateFieldParam{}, err
		}
		return interfaces.UpdateFieldParam{
			SchemaID:     s.ID(),
			FieldID:      fid,
			Name:         ipt.Title,
			Description:  ipt.Description,
			Key:          ipt.Key,
			Multiple:     ipt.Multiple,
			Order:        ipt.Order,
			Unique:       ipt.Unique,
			IsTitle:      ipt.IsTitle,
			Required:     ipt.Required,
			DefaultValue: dv,
			TypeProperty: tp,
		}, nil
	})
	if err != nil {
		return nil, err
	}

	fl, err := usecases(ctx).Schema.UpdateFields(ctx, s.ID(), params, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	return &gqlmodel.FieldsPayload{
		Fields: lo.Map(fl, func(sf *schema.Field, _ int) *gqlmodel.SchemaField {
			return gqlmodel.ToSchemaField(sf, s.TitleField())
		}),
	}, nil
}

// DeleteField is the resolver for the deleteField field.
func (r *mutationResolver) DeleteField(ctx context.Context, input gqlmodel.DeleteFieldInput) (*gqlmodel.DeleteFieldPayload, error) {
	fid, err := gqlmodel.ToID[id.Field](input.FieldID)
	if err != nil {
		return nil, err
	}

	mid := gqlmodel.ToIDRef[id.Model](input.ModelID)
	gid := gqlmodel.ToIDRef[id.Group](input.GroupID)
	param := interfaces.FindOrCreateSchemaParam{
		ModelID:  mid,
		GroupID:  gid,
		Metadata: input.Metadata,
		Create:   true,
	}
	s, err := usecases(ctx).Model.FindOrCreateSchema(ctx, param, getOperator(ctx))
	if err != nil {
		return nil, err
	}

	if err := usecases(ctx).Schema.DeleteField(ctx, s.ID(), fid, getOperator(ctx)); err != nil {
		return nil, err
	}

	return &gqlmodel.DeleteFieldPayload{
		FieldID: input.FieldID,
	}, nil
}

// Model is the resolver for the model field.
func (r *schemaFieldResolver) Model(ctx context.Context, obj *gqlmodel.SchemaField) (*gqlmodel.Model, error) {
	if obj.ModelID != nil {
		return dataloaders(ctx).Model.Load(*obj.ModelID)
	}
	return nil, nil
}

// Schema is the resolver for the schema field.
func (r *schemaFieldReferenceResolver) Schema(ctx context.Context, obj *gqlmodel.SchemaFieldReference) (*gqlmodel.Schema, error) {
	return dataloaders(ctx).Schema.Load(obj.SchemaID)
}

// CorrespondingField is the resolver for the correspondingField field.
func (r *schemaFieldReferenceResolver) CorrespondingField(ctx context.Context, obj *gqlmodel.SchemaFieldReference) (*gqlmodel.SchemaField, error) {
	if obj.CorrespondingFieldID == nil {
		return nil, nil
	}
	ss, err := dataloaders(ctx).Schema.Load(obj.SchemaID)
	if err != nil {
		return nil, err
	}
	ff, ok := lo.Find(ss.Fields, func(f *gqlmodel.SchemaField) bool {
		return f.ID == *obj.CorrespondingFieldID
	})
	if !ok {
		return nil, nil
	}

	return ff, nil
}

// SchemaField returns SchemaFieldResolver implementation.
func (r *Resolver) SchemaField() SchemaFieldResolver { return &schemaFieldResolver{r} }

// SchemaFieldReference returns SchemaFieldReferenceResolver implementation.
func (r *Resolver) SchemaFieldReference() SchemaFieldReferenceResolver {
	return &schemaFieldReferenceResolver{r}
}

type schemaFieldResolver struct{ *Resolver }
type schemaFieldReferenceResolver struct{ *Resolver }
